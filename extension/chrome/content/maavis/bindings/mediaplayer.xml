<?xml version="1.0"?>
<bindings xmlns="http://www.mozilla.org/xbl"
    xmlns:xbl="http://www.mozilla.org/xbl"
    xmlns:html = "http://www.w3.org/1999/xhtml"
    xmlns:xul  = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
    xmlns:svg  = "http://www.w3.org/2000/svg"
    xmlns:xlink= "http://www.w3.org/1999/xlink">

<!--      <html:object id="vlc" type="application/x-vlc-plugin" version="VideoLAN.VLCPlugin.2" />-->

<script>
</script>

  <binding id="videop" display='xul:box'>
    <content>
    </content>
    
    <resources>
      <stylesheet src="chrome://maavis/skin/mediaplayer.css"/>
    </resources>

    <implementation>
     <constructor>
     <![CDATA[
        this._MINVOL = 0;
        this._MAXVOL = 200

        this._setBroadcaster();
        this.setAttribute('playOnce', 'false');
        
        // const - no convienient global scope to define them in 
        this.POLLRATE = 100;
        this.POLLLOOPCOUNT = 30; // 3 seconds
        
        //var frame= document.getAnonymousElementByAttribute(this, 'anonid', 'frame');
        var mythis = this    
		function showImage()
		{
			var e = document.createElementNS("http://www.w3.org/1999/xhtml", 'embed');
			e.setAttribute('top', mythis.getAttribute('top'));
			e.setAttribute('left', mythis.getAttribute('left'));
			e.setAttribute('height', mythis.getAttribute('height'));
			e.setAttribute('width', mythis.getAttribute('width'));
			e.setAttributeNS('http://www.mozilla.org/xbl', 'inherits', 'top,left,width,height')
			if(mythis.getAttribute('invisible') == 'true') // hiding bound obj means player not created
			{
				e.setAttribute('hidden', 'true');
			}

			e.setAttribute('type', "application/x-vlc-plugin");
			e.setAttribute('version', "VideoLAN.VLCPlugin.2");
			e.setAttribute('id', "vlc");
			e.setAttribute('class', "mediaplayer");
			mythis.appendChild(e);

			mythis._vlc = e;

			mythis._wasPlaying = false;
			this._playingItem = undefined;
			mythis._broadcast("isPlaying", "false");
		}
		setTimeout(showImage, 100); // so layout completes without image
		setTimeout(function() {if (mythis._readyFunc) mythis._readyFunc();}, 500); // long enough to alow VLC to start up
        ]]>
     </constructor> 

   <property name="onPlayerReady"   
            onget="return this._readyFunc;// attrib converts everthing to a string"
            onset="this._readyFunc = val; return val;"/>

    <property name="playOnce"
            onget="return this.getAttribute('playOnce')"
            onset="this.setAttribute('playOnce', val); return val;"/>

    <property name="isPlaying" readonly="true"   
            onget="return (this._vlc.playlist.isPlaying) ? 'true' : 'false';" />

    <property name="nowPlaying" readonly="true"   
            onget="return this._playingItem;" />

   <property name="isMuted" readonly="true"   
            onget="return (this._vlc.playlist.isMuted) ? 'true' : 'false';" />

   <method name='_setBroadcaster'>
    <body><![CDATA[
        const broadcasterId = this.id+'_bc';
        if (document.getElementById(broadcasterId) == undefined) // TODO: only one, destructor
        {
            const bc = document.createElement("broadcaster");
            bc.setAttribute("isPlaying", "false");
            bc.setAttribute("isMuted", "false");
            bc.setAttribute("nowPlaying", "undefined");
            bc.id = broadcasterId;
            this.parentNode.appendChild(bc);
            this.bc = bc;
        }
        else
            this.bc = document.getElementById(broadcasterId);
        
        ]]>
    </body>
    </method>

   <method name='_broadcast'>
    <parameter name="what" />
    <parameter name="value" />
    <body><![CDATA[
        this.bc.setAttribute(what, value);
        ]]>
    </body>
    </method>

    <method name='_broadcastPlayStateChange'>
        <body><![CDATA[
        // broadcast playing state if changed
        const isPlaying = this._vlc.playlist.isPlaying;
        if (this._wasPlaying != isPlaying)
        {
            const state = (isPlaying) ? 'true' : 'false'; 
            this._broadcast("isPlaying", state);
            this._wasPlaying = isPlaying;
            if (isPlaying)
            {
                this._broadcast("nowPlaying", this._playingItem);
            }
        }
        ]]>
        </body>
    </method>

   <method name='play'>
    <parameter name="args" />
    <body><![CDATA[
        if (!args.length)
            return;

        this.stop();
        const vlc = this._vlc;
        this._items=[];
        function addToPlaylist(mrl)
        {
            if (utils.isArray(mrl))
            {
                function addToPlaylist2(amrl)
                {
                    vlc.playlist.add(amrl); 
                }
                mrl.forEach(addToPlaylist2);
            }
            else
            {
                vlc.playlist.add(mrl);
            }
            vlc.playlist.play(); // first I hope
        }
        if (utils.isArray(args))
            args.forEach(addToPlaylist);
        else
            addToPlaylist(args);
        vlc.playlist.play();
        
        this._playingItem = 0;
        this._startPoll();
        this._broadcast("isPlaying", "true");
        ]]>
    </body>
    </method>

    <method name='_startPoll'>
    <body><![CDATA[
        this._pollLoopCount = 0; 
        const that = this;
        this._poller = setInterval(function(){that._pollState();}, this.POLLRATE);
        ]]>
    </body>
    </method>

   <method name='_pollState'>
    <body><![CDATA[
        this._broadcastPlayStateChange();

        if (++this._pollLoopCount >= this.POLLLOOPCOUNT)
        {
            this._pollLoopCount = 0;
        }
        else
        {
            return;
        }

        if (this.playOnce == 'true')
            return ;
            
        const vlc = this._vlc;
        const that = this;
        if (!vlc.playlist.isPlaying && this._vlc.input.state != 4) // idle and not paused
        {
            // hack but there seems no easy way, the API rather sucks here
            // if this causes glitches then we'll need to reset the playlist
            function loop()
            {
                //vlc.playlist.play();
                vlc.playlist.next(); // seems to play as well
                that._playingItem ++;
                that._broadcastPlayStateChange();
                setTimeout(function(){if (!vlc.playlist.isPlaying) {vlc.playlist.playItem(0); that._playingItem = 0; that._broadcastPlayStateChange()}}, 200)
            } 
            // loop if still idle after a short time
            setTimeout(function(){if (!vlc.playlist.isPlaying) loop();}, 200); 
        }
        ]]>
    </body>
    </method>
            

   <method name='stop'>
     <body><![CDATA[
        if (this._poller)
            clearInterval(this._poller);
        this._vlc.playlist.stop();
        this._broadcastPlayStateChange();
        ]]>
        </body>
    </method>
 
   <method name='togglePause'>
     <body><![CDATA[
        if (this._vlc.input.state == 3) // playing
        {
            this._vlc.playlist.togglePause();
        }
        else if (this._vlc.input.state == 4) // paused
        {
            this._vlc.playlist.play();
        }
        ]]>
    </body>
    </method>
 
   <method name='restart'>
    <body><![CDATA[
        this._vlc.playlist.stop();
        // poller will restart it
        ]]>
    </body>
    </method>
  
  <method name='prevItem'>
    <body><![CDATA[
        this._vlc.playlist.prev();
        this._pollLoopCount = this.POLLLOOPCOUNT;           // for immediate response
        ]]>
    </body>
    </method>

  <method name='nextItem'>
    <body><![CDATA[
        this._vlc.playlist.stop(); // this allows poller to loop at end of playlist else next does nothing
        this._pollLoopCount = this.POLLLOOPCOUNT;           // for immediate response
        ]]>
    </body>
    </method>

   <method name='playItem'>
    <parameter name="item" />
    <body><![CDATA[
        //TODO what if already playing - also assumes poller is already going
        const n = parseInt(item);
        this._vlc.playlist.playItem(n); // IS the index despite what wiki docs say; plus add() doesn't return an id
        this._playingItem = n; // TODO ask _vlc
        this._broadcast('nowPlaying', this._playingItem);
        ]]>
    </body>
    </method>

  <method name='toggleMute'>
     <body><![CDATA[
        this._vlc.audio.mute = !this._vlc.audio.mute;
        this._broadcast("isMuted", (this._vlc.audio.mute) ? "true" : "false");
        ]]>
    </body>
    </method>
 
   <method name='incVolume'>
     <body><![CDATA[
        this.changeVolume(1);
        ]]>
    </body>
    </method>

   <method name='decVolume'>
     <body><![CDATA[
        this.changeVolume(-1);
        ]]>
    </body>
    </method>

  <method name='changeVolume'>
    <parameter name="upDown" />
    <body><![CDATA[
        const VOLSTEPS = 7;
        const VOLSTEP = Math.floor(this._MAXVOL / VOLSTEPS);
        const delta =  (upDown > 0) ? VOLSTEP : (upDown < 0) ? -VOLSTEP : 0;
        var newVol = this._vlc.audio.volume + delta
        newVol = Math.max(this._MINVOL, newVol);
        newVol = Math.min(newVol, this._MAXVOL);
        this._vlc.audio.volume = newVol;
        ]]>
    </body>
    </method>

  <method name='setVolume'>
    <parameter name="pc" />
    <body><![CDATA[
        var newVol = this._vlc.audio.volume + (this._MAXVOL * Math.floor(pc / 100) )
        newVol = Math.max(this._MINVOL, newVol);
        newVol = Math.min(newVol, this._MAXVOL);
        this._vlc.audio.volume = newVol;
        ]]>
    </body>
    </method>
    
  </implementation>

  </binding>
  
</bindings>

