<?xml version="1.0"?>
<bindings xmlns="http://www.mozilla.org/xbl"
    xmlns:xbl="http://www.mozilla.org/xbl"
    xmlns:html = "http://www.w3.org/1999/xhtml"
    xmlns:xul  = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
    xmlns:svg  = "http://www.w3.org/2000/svg"
    xmlns:xlink= "http://www.w3.org/1999/xlink">

<!--      <html:object id="vlc" type="application/x-vlc-plugin" version="VideoLAN.VLCPlugin.2" />-->

<script>
</script>

  <binding id="videop" display='xul:box'>
    <content>
    </content>
    
    <resources>
      <stylesheet src="chrome://maavis/skin/mediaplayer.css"/>
    </resources>

    <implementation>
     <constructor><![CDATA[
        this._MINVOL = 0;
        this._MAXVOL = 200
     
        this._setBroadcaster();
        
        //var frame= document.getAnonymousElementByAttribute(this, 'anonid', 'frame');
        var mythis = this    
         function showImage()
         {
            var e = document.createElementNS("http://www.w3.org/1999/xhtml", 'embed');
            e.setAttribute('type', "application/x-vlc-plugin");
            e.setAttribute('version', "VideoLAN.VLCPlugin.2");
            e.setAttribute('id', "vlc");
            e.setAttribute('class', "mediaplayer");
            e.setAttributeNS('http://www.mozilla.org/xbl', 'inherits', 'top,left,width,height')
            mythis.appendChild(e);

            mythis._vlc = e;
            
            e.setAttribute('top', mythis.getAttribute('top'));
            e.setAttribute('left', mythis.getAttribute('left'));
            e.setAttribute('height', mythis.getAttribute('height'));
            e.setAttribute('width', mythis.getAttribute('width'));
            
            if(mythis.getAttribute('invisible') == 'true') // hiding bound obj means player not created
                e.setAttribute('hidden', 'true');
            
            if (mythis._readyFunc)
            {
                setTimeout(mythis._readyFunc, 500);
            }
         }
         setTimeout(showImage, 100); // so layout completes without image
        ]]>
     </constructor> 

   <property name="onPlayerReady"   
            onget="return this._readyFunc;// attrib converts everthing to a string"
            onset="this._readyFunc = val; return val;"/>

   <property name="isPlaying" readonly="true"   
            onget="return (this._vlc.playlist.isPlaying) ? 'true' : 'false';" />

   <property name="isMuted" readonly="true"   
            onget="return (this._vlc.playlist.isMuted) ? 'true' : 'false';" />

   <method name='_setBroadcaster'>
    <body><![CDATA[
        const broadcasterId = this.id+'_bc';
        if (document.getElementById(broadcasterId) == undefined) // TODO: only one, destructor
        {
            const bc = document.createElement("broadcaster");
            bc.setAttribute("isPlaying", "false");
            bc.setAttribute("isMuted", "false");
            bc.id = broadcasterId;
            this.parentNode.appendChild(bc);
            this.bc = bc;
        }
        else
            this.bc = document.getElementById(broadcasterId);
        
        ]]>
    </body>
    </method>

   <method name='_broadcast'>
    <parameter name="what" />
    <parameter name="value" />
    <body><![CDATA[
        this.bc.setAttribute(what, value);
        ]]>
    </body>
    </method>

   <method name='play'>
    <parameter name="args" />
    <body><![CDATA[
        const vlc = this._vlc;
        vlc.playlist.clear();
        Components.utils.import("resource://modules/utils.js");
        function addToPlaylist(mrl)
        {
            if (isArray(mrl))
            {
                function addToPlaylist(amrl)
                {
                   vlc.playlist.add(amrl);
                }
                mrl.forEach(addToPlaylist);
                vlc.playlist.play(); // first I hope
            }
            else
            {
                var item = vlc.playlist.add(mrl);
            }
        }
        args.forEach(addToPlaylist);
        vlc.playlist.play();
        
        const that = this;
        this._poller = setInterval(function(){that._pollState();}, 4000);
        this._broadcast("isPlaying", "true");
        ]]>
    </body>
    </method>

   <method name='_pollState'>
    <body><![CDATA[
        // TODO prolly need a state machine if vids can take a while to start
        const vlc = this._vlc;
        if (vlc.input.state == 0) // idle
        {
            // hack but there seems no easy way, the API rather sucks here
            // if this causes glitches then we'll need to reset the playlist
            function loop()
            {
              vlc.playlist.play();
              vlc.playlist.next(); // next loops when playing
            } 
            // loop if still idle after a short time
            setTimeout(function(){if (vlc.input.state == 0) loop();}, 500); 
        }
        ]]>
    </body>
    </method>
            

   <method name='stop'>
     <body><![CDATA[
        if (this._poller)
            clearInterval(this._poller);
        this._vlc.playlist.stop();
        this._broadcast("isPlaying", "false");
        ]]>
    </body>
    </method>
 
   <method name='togglePause'>
     <body><![CDATA[
        // no need to close poller as it will see we are paused
        if (this._vlc.input.state == 3) // playing
        {
            this._vlc.playlist.togglePause();
            this._broadcast("isPlaying", "false");
        }
        else if (this._vlc.input.state == 4) // paused
        {
            this._vlc.playlist.play();
            this._broadcast("isPlaying", "true");
        }
        ]]>
    </body>
    </method>
 
   <method name='restart'>
    <body><![CDATA[
        this._vlc.playlist.stop();
        // poller will restart it
        ]]>
    </body>
    </method>
  
  <method name='prevItem'>
    <body><![CDATA[
        this._vlc.playlist.prev();
        // poller will restart it
        ]]>
    </body>
    </method>

  <method name='nextItem'>
    <body><![CDATA[
        this._vlc.playlist.next();
        // poller will restart it
        ]]>
    </body>
    </method>

  <method name='toggleMute'>
     <body><![CDATA[
        this._vlc.audio.mute = !this._vlc.audio.mute;
        this._broadcast("isMuted", (this._vlc.audio.mute) ? "true" : "false");
        ]]>
    </body>
    </method>
 
   <method name='incVolume'>
     <body><![CDATA[
        this.changeVolume(1);
        ]]>
    </body>
    </method>

   <method name='decVolume'>
     <body><![CDATA[
        this.changeVolume(-1);
        ]]>
    </body>
    </method>

  <method name='changeVolume'>
    <parameter name="upDown" />
    <body><![CDATA[
        const VOLSTEPS = 7;
        const VOLSTEP = Math.floor(this._MAXVOL / VOLSTEPS);
        const delta =  (upDown > 0) ? VOLSTEP : (upDown < 0) ? -VOLSTEP : 0;
        var newVol = this._vlc.audio.volume + delta
        newVol = Math.max(this._MINVOL, newVol);
        newVol = Math.min(newVol, this._MAXVOL);
        this._vlc.audio.volume = newVol;
        ]]>
    </body>
    </method>

  <method name='setVolume'>
    <parameter name="pc" />
    <body><![CDATA[
        var newVol = this._vlc.audio.volume + (this._MAXVOL * Math.floor(pc / 100) )
        newVol = Math.max(this._MINVOL, newVol);
        newVol = Math.min(newVol, this._MAXVOL);
        this._vlc.audio.volume = newVol;
        ]]>
    </body>
    </method>
    
  </implementation>

  </binding>
  
</bindings>

