<?xml version="1.0"?>

<bindings id="buttonBindings"
   xmlns="http://www.mozilla.org/xbl"
   xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
   xmlns:xbl="http://www.mozilla.org/xbl"
   xmlns:svg="http://www.w3.org/2000/svg" 
   xmlns:xlink="http://www.w3.org/1999/xlink"
   xmlns:html="http://www.w3.org/1999/xhtml"
>

  <!-- NB display= needed for event handling -->
  <binding id="touchkey" display="xul:button" 
           extends="chrome://global/content/bindings/button.xml#button-base">
    <resources>
      <stylesheet src="chrome://maavis/skin/touchpad.css"/>
    </resources>

    <implementation>
        <constructor>
            <![CDATA[
            // variables used in following closures
            // TODO tidy this up and it looks like these become public - huh?
            this._label_box = document.getAnonymousElementByAttribute(this, 'anonid', 'label-box');
            if (!this._label_box)
                 throw "XBL binding for <button type=\"touchkey\"/> must contain an element with anonid=\"label-box\"";

            this.obLabel = document.getAnonymousElementByAttribute(this, 'anonid', 'label');

            this._setLabel();
            this._setAction();
            
            // window.addEventListener('DOMContentLoaded', showImage, false); is too early as layout not compelete
 //           const mt = this;
 //           setTimeout(function (){mt._setImage();}, 300); // so layout completes without image
 //                                       // TODO find a better way to know layout has completed
            
            ]]>
        </constructor>

        <property name="row"
                onget="return this.getAttribute('row')"
                onset="this.setAttribute('row', val); return val;"/>
                
        <property name="col"
                onget="return this.getAttribute('col')"
                onset="this.setAttribute('col', val); return val;"/>
                
        <property name="rows"
                onget="return this.getAttribute('rows')">
            <setter><![CDATA[
                this.setAttribute('rows', val);
                this.setOrientation();
                return val;
                ]]>
           </setter>
        </property>

        <property name="label"
                onget="return this.getAttribute('label')">
            <setter><![CDATA[
                this.setAttribute('label', val);
                this._setLabel();
                return val;
                ]]>
           </setter>
        </property>

        <property name="cols"
                onget="return this.getAttribute('cols')" >
            <setter><![CDATA[
                this.setAttribute('cols', val);
                this.setOrientation();
                return val;
                ]]> 
            </setter>
        </property>

        <method name="_setAction">
        <body><![CDATA[
           if (this.hasAttribute('action') && this.getAttribute("action"))
            { 
                Components.utils.import("resource://modules/action.js");
                const action = new Action(this.getAttribute('action'));
                //var win = window;
                //this.addEventListener('command', function(){ win.setTimeout(action.execute, 1);}, false);
                this.addEventListener('command', function(){ action.execute();}, false);
            }
            ]]>
        </body>
      </method>
 
        <method name="setOrientation">
        <body><![CDATA[
            const bHoriz = (this.width / this.height > 2);
            const bHasImage = this.hasAttribute('image');
            const box = this._label_box.parentNode;
            box.orient = (bHoriz) ? 'horizontal' : 'vertical';
            this._label_box.align = (bHoriz) ? 'start' : 'stretch';
            this._label_box.flex = (bHoriz && bHasImage) ? '4' : '0';
            ]]>
        </body>
      </method>

        <method name="_setLabel">
        <body><![CDATA[
            // set the text of the label so it is wrapped
            // TODO prolly want to set/get property+attrib as well
            var label = this.obLabel;
            if (!label)
                 throw "XBL binding for <button type=\"touchkey\"/> binding must contain an element with anonid=\"label\"";
            var text = document.createTextNode(this.getAttribute('label')); 
            if (label.firstChild)
                label.replaceChild(text, label.firstChild);
            else
                label.appendChild(text);
            ]]>
        </body>
      </method>

      <method name="_setImage">
        <body><![CDATA[
          const scale = (this.hasAttribute('image-scale')) ? this.getAttribute('image-scale') : 1;
          const imageFrame = document.getAnonymousElementByAttribute(this, 'anonid', 'image-frame');
          if (!imageFrame)
            throw "XBL binding for <button type=\"touchkey\"/> binding must contain an element with anonid=\"image-frame\"";
          var src = this.getAttribute('image');
          if (src)
          {
              var config = {};
              Components.utils.import("resource://modules/config.js", config);
              src = config.parseURI(src); // TODO review bad design having this here
              
              function setImageSizez()
              {
                // resize to fit keeping aspect ratio
                const imageWidth = this.naturalWidth;
                const imageHeight = this.naturalHeight;
                const availableWidth = imageFrame.boxObject.width; // note could also use getComputedStyle
                const availableHeight = imageFrame.boxObject.height;
                var width = availableWidth;
                var height = availableWidth * imageHeight / imageWidth;
                if (height > availableHeight)
                {
                    height = availableHeight;
                    width = availableHeight * imageWidth / imageHeight;
                }
            //window.alert(availableWidth+'x'+availableHeight + ' '+ width+'x'+height);
            
                imageFrame.align='center';
                imageFrame.pack='center';

                function setImageSize()
                {
                    // add child image (xul:image) not HTML to avoid display problems
                    var i = document.createElement('image');
                    i.setAttribute('class', 'touchkey-image');
                    i.setAttribute('src', src);
                    i.width = width * scale;
                    i.height = height * scale;
                    if (imageFrame.firstChild)
                      imageFrame.replaceChild(i, imageFrame.firstChild);
                    else
                      imageFrame.appendChild(i);
                }
                  
                setTimeout(setImageSize, 1); // seem to need this as well
              }
              
              // create a temp HTML img which includes the actual image size so we can keep aspect ratio
              var i = document.createElementNS("http://www.w3.org/1999/xhtml", 'img');
              i.setAttribute('src', src);
              i.onload = setImageSizez;
            }
            else
            {
                imageFrame.collapsed='true';
            }
        ]]>
        </body>
      </method>

    </implementation>
    
                
   <content>
        <xul:vbox anonid='box' class="box-inherit touchkey-box" xbl:inherits="align,dir,pack,orient"
                align="stretch" pack="center" orient="vertical" flex="1">
            <xul:vbox anonid='image-frame' flex='1' />
            <xul:vbox anonid="label-box" flex='0' pack="center" >
                <xul:label anonid='label' class="touchkey-text" xbl:inherits="accesskey,crop"></xul:label>
            </xul:vbox>
        </xul:vbox> 
      </content>
  </binding>


  <binding id="togglekey" 
           extends="chrome://maavis/content/bindings/touchpad.xml#touchkey">

    <implementation>
        <constructor>
            <![CDATA[
            this.setAttribute('labelA', this.getAttribute('label'));
            this.setAttribute('imageA', this.getAttribute('image'));
            if (this.getAttribute('watch') != "") // TODO must be a better way to get side effects on init
            {
                this.watch = this.getAttribute('watch');
            }
        ]]>
        </constructor>
        
   <property name="watch"   
            onget="return this.getAttribute('watch')">
            <setter><![CDATA[
                this.autoToggle = 'false';
                this.setAttribute('watch', val); 
                const w = val.split('.');
                var obs = document.createElement('observes');
                const bcid = w[0]+"_bc";
                obs.setAttribute("element", w[0]+"_bc");
                obs.setAttribute("attribute", w[1]);
//                obs.setAttribute("onbroadcast", 'alert(this.getAttribute("'+w[1]+'"));'); //TODO why not?
                //obs.setAttribute("onbroadcast", 'alert(document.getElementById("'+w[0]+'").'+w[1]+')');
                const str = 'this.parentNode.state = (document.getElementById("'+w[0]+'").'+w[1]+' == "true") ? "a" : "b";';
                obs.setAttribute("onbroadcast", str);
                const curobs = this.getElementsByClassName("observes");
                if (curobs.length)
                    this.replaceChild(obs, curobs);
                else
                    this.appendChild(obs);
                return val;
                ]]>
           </setter>
   </property>

   <property name="state"   
            onget="return this.getAttribute('state')"
            onset="this.setAttribute('state', val); this._setState(); return val;"/>

   <property name="autoToggle"   
            onget="return this.getAttribute('autoToggle')"
            onset="this.setAttribute('autoToggle', val); return val;"/>

     <method name="_toggleState">
        <body>
        <![CDATA[
        alert('ho');
          if (!this.disabled) 
          {
            this.state = (this.state == 'a') ? 'b' : 'a';
            this._setState();
          }
        ]]>
        </body>
      </method>

     <method name="_setState">
        <body>
        <![CDATA[
            this.setAttribute('label', ((this.state == 'a') ? this.getAttribute('labelA') : this.getAttribute('labelB')));
            this._setLabel()
            this.setAttribute('image', ((this.state == 'a') ? this.getAttribute('imageA') : this.getAttribute('imageB')));
            this._setImage();
        ]]>
        </body>
      </method>
    </implementation>

    <handlers>
      <!-- While it would seem we could do this by handling oncommand, we can't
           because any external oncommand handlers might get called before ours,
           and then they would see the incorrect value of checked. Additionally
           a command attribute would redirect the command events anyway.-->
        <!-- I'm assumong don't need to call base class methods -->
      <handler event="click" button="0" action="if (this.autoToggle == 'true') this._toggleState();"/>
      <handler event="keypress" key=" " action="if (this.autoToggle == 'true') this._toggleState();"/>
    </handlers>
    
    </binding>

  <binding id="chatterkey" 
           extends="chrome://maavis/content/bindings/touchpad.xml#touchkey">

    <implementation>
        <constructor>
            <![CDATA[
          this._tts = Components.classes["@fullmeasure.co.uk/tts;1"]
                         .getService(Components.interfaces.ITTS);

            if (this.speakOnLoad)
            {
                var that = this;
                window.setTimeout(function(){that.speak();}, 100);
            }
        ]]>
        </constructor>

    <property name="spokenLabel"
            onget="return this.getAttribute('spokenLabel')"
            onset="this.setAttribute('spokenLabel', val); return val;"/>
                
    <property name="speakOnLoad"
            onget="return this.getAttribute('speakOnLoad')"
            onset="this.setAttribute('speakOnLoad', val); return val;"/>
                
    <method name="speak">
        <body>
        <![CDATA[
          const what = (this.spokenLabel) ? this.spokenLabel : this.label;
          this._tts.speak(what);
        ]]>
        </body>
      </method>
    </implementation>

    <handlers>
      <handler event="command" action="this.speak();"/>
    </handlers>
    
    </binding>

   <binding id="touchpad">
    <resources>
      <stylesheet src="chrome://maavis/skin/touchpad.css"/>
    </resources>

    <implementation>
        <constructor><![CDATA[
            var stack = document.getAnonymousElementByAttribute(this, 'anonid', 'stack');
            if (!stack)
                 throw "XBL binding for <button type=\"touchpad\"/> must contain an element with anonid=\"stack\"";
            this._stack = stack;
            
            const that = this;
            function f()
            {
                that.layoutKeys(); // TODO we're fighting against gecko here so find a better way
            }
            window.addEventListener('load', function(){setTimeout(f, 1);}, false);
        ]]>
        </constructor>

      <property name="rows"
                onget="return this.getAttribute('rows')"
                onset="this.setAttribute('rows', val); return val;"/>
                
      <property name="cols"
                onget="return this.getAttribute('cols')"
                onset="this.setAttribute('cols', val); return val;"/>

     <method name="_getGridCellDimensions">
        <body><![CDATA[
            const width = this._stack.boxObject.width;
            const height = this._stack.boxObject.height;
            var size = {};
            size.h = Math.floor(width / this.cols);
            size.v = Math.floor(height / this.rows);
            return size;
        ]]>
        </body>
      </method>

     <method name="_positionKey">
        <parameter name='key' />
        <body><![CDATA[
                const size = this._getGridCellDimensions();
                const style = window.getComputedStyle(key,null);
                const hmargin = parseInt(style.getPropertyValue('margin-left'))
                              + parseInt(style.getPropertyValue('margin-right'));
                const vmargin = parseInt(style.getPropertyValue('margin-top'))
                              + parseInt(style.getPropertyValue('margin-bottom'));
                if (key.nodeName == "touchkey" || key.nodeName == "togglekey" || key.nodeName == "chatterkey") // TODO do this better
                {   
                    key.top = key.row * size.v;
                    key.left = key.col * size.h;
                    key.height = (key.rows * size.v) - vmargin;
                    key.width = (key.cols * size.h) - hmargin;
                    key.setOrientation();
                    key._setImage();
                    key._setLabel();
                }
                else if (key.nodeName == "slide")
                {   
                    key.setAttribute('top', key.getAttribute('row') * size.v);
                    key.setAttribute('left', key.getAttribute('col') * size.h);
                    key.setAttribute('height', (key.getAttribute('rows') * size.v) - vmargin);
                    key.setAttribute('width', (key.getAttribute('cols') * size.h) - hmargin);
                    key.scaleImage();
                }
                else if (key.nodeName == "slideshow")
                {   
                    key.setAttribute('top', key.getAttribute('row') * size.v);
                    key.setAttribute('left', key.getAttribute('col') * size.h);
                    key.setAttribute('height', (key.getAttribute('rows') * size.v) - vmargin);
                    key.setAttribute('width', (key.getAttribute('cols') * size.h) - hmargin);
                }
                else
                {
                    key.setAttribute('top', key.getAttribute('row') * size.h);
                    key.setAttribute('left', key.getAttribute('col') * size.w);
                    key.setAttribute('height', (key.getAttribute('rows') * size.h) - vmargin);
                    key.setAttribute('width', (key.getAttribute('cols') * size.w) - hmargin);
                }
        ]]>
        </body>
      </method>

     <method name="_dumpKey">
        <parameter name='key' />
        <body><![CDATA[
           alert(key.nodeName+': '+key.label+': '+key.left +':'+key.top+'x'+key.width+':'+key.height);
        ]]>
        </body>
      </method>

     <method name="createKey">
        <parameter name='row' />
        <parameter name='col' />
        <parameter name='rows' />
        <parameter name='cols' />
        <parameter name='label' />
        <parameter name='image' />
        <parameter name='action' />
        <body><![CDATA[
           var key = document.createElement("touchkey");
           key.setAttribute("row", row);
           key.setAttribute("col", col);
           key.setAttribute("rows", rows);
           key.setAttribute("cols", cols);
           key.setAttribute("label", label);
           if (image)
           {
             key.setAttribute("image", image);
           }
           key.setAttribute("action", action);
           this._stack.appendChild(key);
           this._positionKey(key); // sets the image too
           return key
        ]]>
        </body>
      </method>

    <method name="layoutKeys">
        <body><![CDATA[
            const keys = this.childNodes;
            for (var i = 0; i < keys.length; i++) 
            {
                var key = keys[i];
                this._positionKey(key);
//                this._dumpKey(key);
            };

        ]]>
        </body>
      </method>
    </implementation>

    <content>
        <xul:stack anonid='stack' orient='vertical' flex='1'>
          <children/>
        </xul:stack>
      </content>
  </binding>
 
</bindings>
