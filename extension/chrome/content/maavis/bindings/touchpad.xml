<?xml version="1.0"?>

<bindings id="buttonBindings"
   xmlns="http://www.mozilla.org/xbl"
   xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
   xmlns:xbl="http://www.mozilla.org/xbl"
   xmlns:svg="http://www.w3.org/2000/svg" 
   xmlns:xlink="http://www.w3.org/1999/xlink"
   xmlns:html="http://www.w3.org/1999/xhtml"
>

  <!-- NB display= needed for event handling -->
  <binding id="touchkey" display="xul:button" 
           extends="chrome://global/content/bindings/button.xml#button-base">
    <resources>
      <stylesheet src="chrome://maavis/skin/touchpad.css"/>
    </resources>

    <implementation>
        <constructor>
            <![CDATA[
            // variables used in following closures
            // TODO tidy this up and it looks like these become public - huh?
            this._label_box = document.getAnonymousElementByAttribute(this, 'anonid', 'label-box');
            if (!this._label_box)
                 throw "XBL binding for <button type=\"touchkey\"/> must contain an element with anonid=\"label-box\"";
            this._image_box = document.getAnonymousElementByAttribute(this, 'anonid', 'image-frame');
            if (!this._image_box)
                 throw "XBL binding for <button type=\"touchkey\"/> must contain an element with anonid=\"image-frame\"";

            this.obLabel = document.getAnonymousElementByAttribute(this, 'anonid', 'label');

            // get containing touchpad.
            var node=this;
            while (node.tagName != 'touchpad')
                node = node.parentNode;
            this.obTouchPad =  node;
            
            const that = this;
            function foo()
            {
                that._setLabel();
                that._setAction();
            }
            setTimeout(foo, 1); // alow labels to be set correctly even for those define in XUL
            
            // window.addEventListener('DOMContentLoaded', showImage, false); is too early as layout not compelete
 //           const mt = this;
 //           setTimeout(function (){mt._setImage();}, 300); // so layout completes without image
 //                                       // TODO find a better way to know layout has completed
            
          this._tts = Components.classes["@fullmeasure.co.uk/tts;1"]
                         .getService(Components.interfaces.ITTS);
        ]]>
        </constructor>

        <property name="row"
                onget="return this.getAttribute('row')"
                onset="this.setAttribute('row', val); return val;"/>
                
        <property name="col"
                onget="return this.getAttribute('col')"
                onset="this.setAttribute('col', val); return val;"/>
                
        <property name="rows"
                onget="return this.getAttribute('rows')">
            <setter><![CDATA[
                this.setAttribute('rows', val);
                this.setOrientation();
                return val;
                ]]>
           </setter>
        </property>

        <property name="alwaysShowLabel"
                onget="return this.getAttribute('alwaysShowLabel')"
                onset="this.setAttribute('alwaysShowLabel', val); return val;"/>

        <property name="prompt"
                onget="return this.getAttribute('prompt')"
                onset="this.setAttribute('prompt', val); return val;"/>

        <property name="cols"
                onget="return this.getAttribute('cols')" >
            <setter><![CDATA[
                this.setAttribute('cols', val);
                this.setOrientation();
                return val;
                ]]> 
            </setter>
        </property>

        <property name="label"
                onget="return this.getAttribute('label')">
            <setter><![CDATA[
                this.setAttribute('label', val);
                this._setLabel();
                return val;
                ]]>
           </setter>
        </property>

       <property name="_showLabel"
                readonly="true"
                onget='return (this.alwaysShowLabel || (this.obTouchPad.getAttribute("showLabels") == "true")) ;'/>
                
        <property name="leftalignlabel"
                onget="return this.getAttribute('leftalignlabel')">
            <setter><![CDATA[
                this.setAttribute('leftalignlabel', val);
                if (val == 'true')
                {
                    document.getAnonymousElementByAttribute(this, 'anonid', 'label').className+=' lefty';                
                }
                return val;
                ]]>
           </setter>
        </property>

        <method name="_setAction">
        <body><![CDATA[
           if (this.hasAttribute('action') && this.getAttribute("action"))
            { 
                Components.utils.import("resource://modules/action.js");
                const action = new Action(this.getAttribute('action'));
                //var win = window;
                //this.addEventListener('command', function(){ win.setTimeout(action.execute, 1);}, false);
                this.addEventListener('command', function(){ action.execute();}, false);
            }
            ]]>
        </body>
      </method>
 
        <method name="setOrientation">
        <body><![CDATA[
            const box = this._label_box.parentNode;

            const bShowImage = (this.hasAttribute('image') && (this.obTouchPad.getAttribute("showImages") == 'true'));
            const bHoriz = ((this.width / this.height) > 2);
            if  (bHoriz)
            {
                //const bHasImage = this.hasAttribute('image');
                box.orient =  'horizontal';
                box.pack =  'center';
                this._label_box.orient =  'horizontal';
                this._image_box.orient =  'horizontal';
                this._image_box.flex =  '0';
                const boxw = box.boxObject.width;
                this._label_box.flex = (bShowImage) ? '0' : '1';
                this._image_box.width = (bShowImage && this._showLabel) ? boxw/4-5 : null;
                this._label_box.width = (bShowImage && this._showLabel) ? 3*boxw/4-5 :null;
            }
            else
            {
                box.orient =  'vertical';
                this._label_box.orient =  'vertical';
                this._image_box.flex =  (bShowImage) ? '1' : '0';
                this._label_box.flex = '0';
                this._label_box.align = 'stretch';
            }
           ]]>
        </body>
      </method>


        <method name="_setLabel">
        <body><![CDATA[
            // set the text of the label so it is wrapped
            // TODO prolly want to set/get property+attrib as well
            if (!this._showLabel)
                return
                
            var label = this.obLabel;
            if (!label)
                 throw "XBL binding for <button type=\"touchkey\"/> binding must contain an element with anonid=\"label\"";
			label.width = label.parentNode.width - 20 ;
			label.value = this.getAttribute('label');
            ]]>
        </body>
      </method>

      <method name="_setImage">
        <body><![CDATA[
           if (this.obTouchPad.showImages != 'true') // skip stack
            return;
            
          const scale = (this.hasAttribute('image-scale')) ? this.getAttribute('image-scale') : 1;
          const imageFrame = document.getAnonymousElementByAttribute(this, 'anonid', 'image-frame');
          if (!imageFrame)
            throw "XBL binding for <button type=\"touchkey\"/> binding must contain an element with anonid=\"image-frame\"";
          var src = this.getAttribute('image');
          if (src)
          {
              var config = {};
              Components.utils.import("resource://modules/config.js", config);
              src = config.parseURI(src); // TODO review bad design having this here
 
              const isSVG = (src.slice(-4).toLowerCase() == '.svg');
  
              function setImageSizez()
              {
                const availableWidth = imageFrame.boxObject.width; // note could also use getComputedStyle
                const availableHeight = imageFrame.boxObject.height;

                if (isSVG)
                {
                    width = availableWidth;
                    height = availableHeight;
                }
                else
                {
                    // resize to fit keeping aspect ratio
                    const imageWidth = this.naturalWidth;
                    const imageHeight = this.naturalHeight;
                    var width = availableWidth;
                    var height = availableWidth * imageHeight / imageWidth;
                    if (height > availableHeight)
                    {
                        height = availableHeight;
                        width = availableHeight * imageWidth / imageHeight;
                    }
                }
                width *=  scale;
                height *=  scale;
        //window.alert(availableWidth+'x'+availableHeight + ' '+ width+'x'+height);
            
                imageFrame.align='center';
                imageFrame.pack='center';
                
                const that = this;
                function setImageSize()
                {
                    if (isSVG)
                    { 
                        i = that;
                    }
                    else
                    {
                        // add child image (xul:image) not HTML to avoid display problems
                        var i = document.createElement('image');
                        i.setAttribute('src', src);
                    }
                    i.width = width;
                    i.height = height;
                    i.setAttribute('class', 'touchkey-image');
                    if (imageFrame.firstChild)
                      imageFrame.replaceChild(i, imageFrame.firstChild);
                    else
                      imageFrame.appendChild(i);
                }
                  
                setTimeout(setImageSize, 1); // seem to need this as well
              }
              
              if (isSVG)
              {
                    // no obvious way of getting at image size from file.
                    i = document.createElementNS("http://www.w3.org/1999/xhtml", 'object');
                    i.type='image/svg+xml';
                    i.data=src;
                    setTimeout(function(){setImageSizez.call(i)}, 1);
              }
              else
              {
                    // create a temp HTML img which includes the actual image size so we can keep aspect ratio
                    var i = document.createElementNS("http://www.w3.org/1999/xhtml", 'img');
                    i.onload = setImageSizez;
                    i.src = src;
                }
            }
            else
            {
                imageFrame.collapsed='true';
            }
        ]]>
        </body>
      </method>


     <property name="spokenLabel"
            onget="return this.getAttribute('spokenLabel')"
            onset="this.setAttribute('spokenLabel', val); return val;"/>
                
    <method name="playPrompt">
        <body>
        <![CDATA[
        if (this.prompt)
         {
         utils.logit(this.prompt);
            //TODO may need to cach the player
            const player = document.createElement('videop');
            utils.logit(player.tagName);
            
            const that = this;
            setTimeout(function(){player.play(that.prompt);}, 1000);
         }
         else
         {
          this.speak();
          }
        ]]>
        </body>
      </method>


    <method name="speak">
        <body>
        <![CDATA[
          const what = (this.spokenLabel) ? this.spokenLabel : this.label;
          this._tts.speak(what+'.'); // add . so sound correct
        ]]>
        </body>
      </method>

    </implementation>
    
                
   <content>
        <xul:vbox anonid='box' class="box-inherit touchkey-box" xbl:inherits="align,dir,pack,orient"
                align="stretch" pack="center" flex="1">
            <xul:vbox anonid='image-frame' flex='1' />
            <xul:vbox anonid="label-box" flex='0' align="center">
                <xul:label anonid='label' flex='1' class="touchkey-text" xbl:inherits="accesskey,crop"> </xul:label>
            </xul:vbox>
        </xul:vbox> 
      </content>
  </binding>


  <binding id="togglekey" 
           extends="chrome://maavis/content/bindings/touchpad.xml#touchkey">

    <implementation>
        <constructor>
            <![CDATA[
            this.setAttribute('labelA', this.getAttribute('label'));
            this.setAttribute('imageA', this.getAttribute('image'));
            if (this.getAttribute('watch') != "") // TODO must be a better way to get side effects on init
            {
                this.watch = this.getAttribute('watch');
            }
        ]]>
        </constructor>
        
   <property name="watch"   
            onget="return this.getAttribute('watch')">
            <setter><![CDATA[
                this.autoToggle = 'false';
                this.setAttribute('watch', val); 
                const w = val.split('.');
                var obs = document.createElement('observes');
                obs.setAttribute("element", w[0]+"_bc");
                obs.setAttribute("attribute", w[1]);
                const str = 'this.parentNode.state = (this.parentNode.getAttribute("'+w[1]+'") == "true") ? "b" : "a";'; // observer sets on parent
                obs.setAttribute("onbroadcast", str);
                const curobs = this.getElementsByClassName("observes");
                if (curobs.length)
                    this.replaceChild(obs, curobs);
                else
                    this.appendChild(obs);
                return val;
                ]]>
           </setter>
   </property>

   <property name="state"   
            onget="return this.getAttribute('state')"
            onset="this.setAttribute('state', val); this._setState(); return val;"/>

   <property name="autoToggle"   
            onget="return this.getAttribute('autoToggle')"
            onset="this.setAttribute('autoToggle', val); return val;"/>

     <method name="_toggleState">
        <body>
        <![CDATA[
          if (!this.disabled) 
          {
            this.state = (this.state == 'a') ? 'b' : 'a';
            this._setState();
          }
        ]]>
        </body>
      </method>

     <method name="_setState">
        <body>
        <![CDATA[
            this.setAttribute('label', ((this.state == 'a') ? this.getAttribute('labelA') : this.getAttribute('labelB')));
            this._setLabel()
            this.setAttribute('image', ((this.state == 'a') ? this.getAttribute('imageA') : this.getAttribute('imageB')));
            this._setImage();
        ]]>
        </body>
      </method>
    </implementation>

    <handlers>
      <!-- While it would seem we could do this by handling oncommand, we can't
           because any external oncommand handlers might get called before ours,
           and then they would see the incorrect value of checked. Additionally
           a command attribute would redirect the command events anyway.-->
        <!-- I'm assumong don't need to call base class methods -->
      <handler event="click" button="0" action="if (this.autoToggle == 'true') this._toggleState();"/>
      <handler event="keypress" key=" " action="if (this.autoToggle == 'true') this._toggleState();"/>
    </handlers>
    
    </binding>

  <binding id="chatterkey" 
           extends="chrome://maavis/content/bindings/touchpad.xml#touchkey">

    <implementation>
        <constructor>
            <![CDATA[
            if (this.speakOnLoad == "true")
            {
                var that = this;
                function speak()
                {   if (that.speakOnLoad == "true")
                    {
                    //ensure speaks after display of new page
                    window.setTimeout(function(){that.speak();}, 500);
                    }
                }
                window.addEventListener('load', speak, false);
            }
        ]]>
        </constructor>

    <property name="speakOnLoad"
            onget="return this.getAttribute('speakOnLoad')"
            onset="this.setAttribute('speakOnLoad', val); return val;"/>

    </implementation>

    <handlers>
      <handler event="command" action="this.speak();"/>
    </handlers>
    
    </binding>

   <binding id="touchpad">
    <resources>
      <stylesheet src="chrome://maavis/skin/touchpad.css"/>
    </resources>

    <handlers>
        <handler event="keypress" keycode="vk_tab" modifiers="" preventdefault ='true'>
        <![CDATA[ 
        this.navigate(1, true);
        ]]>
        </handler>
        <handler event="keypress" keycode="vk_tab" modifiers='shift' preventdefault ='true'>
        <![CDATA[
        this.navigate(0, true);
        ]]>
        </handler>
        <handler event="keypress" keycode="vk_right" modifiers="" preventdefault ='true'>
        <![CDATA[
        event.preventDefault()
        this.navigate(1, true);
        ]]>
        </handler>
        <handler event="keypress" keycode="vk_left" modifiers='' preventdefault ='true'>
        <![CDATA[
        event.preventDefault()
        this.navigate(0, true);
        ]]>
        </handler>
        <!-- why doesn't this work? Docs say can use custom events -->
        <handler event="joystickdown" >
        <![CDATA[
        window.alert('aaa');
        ]]>
        </handler>
      </handlers>

   <implementation>
        <constructor><![CDATA[
            var stack = document.getAnonymousElementByAttribute(this, 'anonid', 'stack');
            if (!stack)
                 throw "XBL binding for <button type=\"touchpad\"/> must contain an element with anonid=\"stack\"";
            this._stack = stack;
            
            var nodes = [];
            for (var i = 0; i<this.childNodes.length; i++)
            {
                const node = this.childNodes[i];
                if (node.tagName != 'selections')
                {
                    nodes.push(node); 
                }
            }
            const that = this;
            // we seem to need to move them here - ideally would derive binding from stack
            nodes.forEach(function(node){ that.removeChild(node);
                                                    that._stack.appendChild(node);
                                                    });
            this._firstPageKey = this._stack.firstChild; // we insert selections before this for tab ordering
            
            function f()
            {
                that.layoutKeys(); // TODO we're fighting against gecko here so find a better way
            }
            window.addEventListener('load', function(){setTimeout(f, 1);}, false);
            
            this.setAttribute('showLabels', 'true')
            this.setAttribute('showImages', 'true')
            //this._tabGroupIndexs = {};
            this._nSelection = 0;
            this._currentKey = null;
            //setTimeout(function(){window.alert(that.children);}, 1);
        ]]>
        </constructor>

         <property name="content"
                onget="return this._stack;"
                readonly="true"/>

        <property name="rows"
                onget="return this.getAttribute('rows')"
                onset="this.setAttribute('rows', val); return val;"/>
                
      <property name="cols"
                onget="return this.getAttribute('cols')"
                onset="this.setAttribute('cols', val); return val;"/>

      <property name="showImages"
                onget="return this.getAttribute('showImages')"
                onset="this.setAttribute('showImages', val); return val;"/>
                
      <property name="showLabels"
                onget="return this.getAttribute('showLabels')"
                onset="this.setAttribute('showLabels', val); return val;"/>
                
     <method name="_assignTabIndex">
        <parameter name='key' />
        <body><![CDATA[
            // isn't working - only 0 or 1 seem to work for added keys
           key.setAttribute("tabindex", "0");
            return; 
            
            const tabgroup = key.getAttribute("tabgroup");
            var tabindex=key.tabindex;
            if (tabgroup == '' && tabindex == undefined)
            {
                key.setAttribute("tabindex", "-1");
            }
            if (tabgroup == '' || (tabgroup != '' && tabindex == "-1"))
                return;
            if (tabindex == undefined)
                tabindex = '0';
            const ntabindex =  parseInt(tabindex);
            const ntabgroup =  parseInt(tabgroup);
            if (!(tabgroup in this._tabGroupIndexs))
            {
                this._tabGroupIndexs[tabgroup] = (ntabgroup * 1000) + 1; // so cant be 0
            }
            const tabval =  (ntabindex == 0) ? this._tabGroupIndexs[tabgroup] : (ntabgroup * 1000 +  ntabindex);
            key.setAttribute("tabindex", tabval.toString()); // what if mixed 0 and numbers
            this._tabGroupIndexs[tabgroup] = this._tabGroupIndexs[tabgroup]+1;
         ]]>
        </body>
      </method>

       <method name="select">
        <body><![CDATA[
           var current = this._currentKey;
           if (current)
           {
             //current.focus();
             current.click();
            }
         ]]>
        </body>
      </method>
 

        <method name="navigate">
        <parameter name='direction' />
        <parameter name='focus' />
        <body><![CDATA[
            var next = null;
            var current = this._currentKey;
            function skipNode(node)
            {
               return (node.disabled || (node.className.indexOf('scankey') == -1));
            }
            next = current;
            if (direction == 0)
            {
                do
                {
                    if (!next)
                        next =  this._stack.lastChild;
                    else
                        next = next.previousSibling;
                }
                while (!next || skipNode(next))
            }
            else if (direction == 1)
            {
                do
                {
                    if (!next)
                        next =  this._stack.firstChild;
                    else
                        next = next.nextSibling;
                }
                while (!next || skipNode(next))
            }
            this._currentKey = next;
            if (focus)
                next.focus();
         ]]>
        </body>
      </method>

     <method name="_getGridCellDimensions">
        <body><![CDATA[
            const width = this._stack.boxObject.width;
            const height = this._stack.boxObject.height;
            var size = {};
            size.h = Math.floor(width / this.cols);
            size.v = Math.floor(height / this.rows);
            return size;
        ]]>
        </body>
      </method>

     <method name="_positionKey">
        <parameter name='key' />
        <body><![CDATA[
                const size = this._getGridCellDimensions();
                const style = window.getComputedStyle(key,null);
                const hmargin = parseInt(style.getPropertyValue('margin-left'))
                              + parseInt(style.getPropertyValue('margin-right'));
                const vmargin = parseInt(style.getPropertyValue('margin-top'))
                              + parseInt(style.getPropertyValue('margin-bottom'));
                if (key.nodeName == "touchkey" || key.nodeName == "togglekey" || key.nodeName == "chatterkey") // TODO do this better
                {   
                    key.top = key.row * size.v;
                    key.left = key.col * size.h;
                    key.height = (key.rows * size.v) - vmargin;
                    key.width = (key.cols * size.h) - hmargin;
                    key.setOrientation();
                    key._setImage();
                    key._setLabel();
                }
                else if (key.nodeName == "slide")
                {   
                    key.setAttribute('top', key.getAttribute('row') * size.v);
                    key.setAttribute('left', key.getAttribute('col') * size.h);
                    key.setAttribute('height', (key.getAttribute('rows') * size.v) - vmargin);
                    key.setAttribute('width', (key.getAttribute('cols') * size.h) - hmargin);
                    key.scaleImage();
                }
                else if (key.nodeName == "slideshow")
                {   
                    key.setAttribute('top', key.getAttribute('row') * size.v);
                    key.setAttribute('left', key.getAttribute('col') * size.h);
                    key.setAttribute('height', (key.getAttribute('rows') * size.v) - vmargin);
                    key.setAttribute('width', (key.getAttribute('cols') * size.h) - hmargin);
                }
                else
                {
                    key.setAttribute('top', key.getAttribute('row') * size.v);
                    key.setAttribute('left', key.getAttribute('col') * size.h);
                    key.setAttribute('height', (key.getAttribute('rows') * size.v) - vmargin);
                    key.setAttribute('width', (key.getAttribute('cols') * size.h) - hmargin);
                }
        ]]>
        </body>
      </method>

     <method name="_dumpKey">
        <parameter name='key' />
        <body><![CDATA[
           alert(key.nodeName+': '+key.label+': '+key.left +':'+key.top+'x'+key.width+':'+key.height);
        ]]>
        </body>
      </method>

     <method name="createKey">
        <parameter name='row' />
        <parameter name='col' />
        <parameter name='rows' />
        <parameter name='cols' />
        <parameter name='label' />
        <parameter name='image' />
        <parameter name='image_scale' />
        <parameter name='action' />
        <parameter name='crop' />
        <body><![CDATA[
           var key = document.createElement("touchkey");
           key.setAttribute("row", row);
           key.setAttribute("col", col);
           key.setAttribute("rows", rows);
           key.setAttribute("cols", cols);
           key.setAttribute("label", label);
           key.setAttribute("crop", crop);
           key.setAttribute("tabgroup", "1");
           this._assignTabIndex(key);
           if (image)
           {
             key.setAttribute("image", image);
           }
           if (image_scale)
           {
             key.setAttribute("image-scale", image_scale);
           }
           key.setAttribute("action", action);
           this._stack.appendChild(key);
           this._positionKey(key); // sets the image too
           return key
        ]]>
        </body>
      </method>

     <method name="addSelectionItem">
        <parameter name='label' />
        <parameter name='image' />
        <parameter name='image_scale' />
        <parameter name='action' />
        <parameter name='crop' />
        <parameter name='prompt' />
        <body><![CDATA[
            const selection = this.getElementsByTagName('selections')[0];
            if  (!selection)
                return;
                
            const col = parseInt(selection.getAttribute('col'));
            const row = parseInt(selection.getAttribute('row'));
            const cols = parseInt(selection.getAttribute('cols'));
            const rows = parseInt(selection.getAttribute('rows'));
            const itemcols = parseInt(selection.getAttribute('itemcols'));
            const itemrows = parseInt(selection.getAttribute('itemrows'));
            // l->r t->b
            const nitemcols = Math.floor(cols / itemcols);
            const nitems = nitemcols * this._nSelection;
            const itemcol = (this._nSelection % nitemcols) * itemcols + col;
            const itemrow = Math.floor(this._nSelection / nitemcols ) * itemrows + row;
            this._nSelection ++;

           var key = document.createElement("touchkey");
           key.setAttribute("row", itemrow);
           key.setAttribute("col", itemcol);
           key.setAttribute("rows", itemrows);
           key.setAttribute("cols", itemcols);
           
           key.setAttribute("label", label);
           key.setAttribute("crop", crop);
           key.setAttribute("prompt", prompt);
           key.setAttribute("tabgroup", "1");
           this._assignTabIndex(key);

            if (image)
           {
             key.setAttribute("image", image);
           }
           if (image_scale)
           {
             key.setAttribute("image-scale", image_scale);
           }
           key.setAttribute("action", action);
           this._stack.insertBefore(key, this._firstPageKey);
           this._positionKey(key); // sets the image too
           return key
        ]]>
        </body>
      </method>

    <method name="layoutKeys">
        <body><![CDATA[
            const keys = this._stack.childNodes;
            for (var i = 0; i < keys.length; i++) 
            {
                var key = keys[i];
                this._assignTabIndex(key);
                this._positionKey(key);
//                this._dumpKey(key);
            };

        ]]>
        </body>
      </method>
    </implementation>

    <content>
        <xul:stack anonid='stack' orient='vertical' flex='1'>
          <children/>
        </xul:stack>
      </content>
  </binding>
 
</bindings>
