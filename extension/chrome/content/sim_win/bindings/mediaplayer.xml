<?xml version="1.0"?>
<bindings xmlns="http://www.mozilla.org/xbl"
    xmlns:xbl="http://www.mozilla.org/xbl"
    xmlns:html = "http://www.w3.org/1999/xhtml"
    xmlns:xul  = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
    xmlns:svg  = "http://www.w3.org/2000/svg"
    xmlns:xlink= "http://www.w3.org/1999/xlink">

<!--      <html:object id="vlc" type="application/x-vlc-plugin" version="VideoLAN.VLCPlugin.2" />-->

<script>
</script>

  <binding id="videop" display='xul:box'>
    <content>
      <broadcaster anonid="play_state" playing="false"/>
    </content>
    
    <resources>
      <stylesheet src="chrome://sim_win/skin/mediaplayer.css"/>
    </resources>

    <implementation>
     <constructor><![CDATA[
        this._MINVOL = 0;
        this._MAXVOL = 200
     
        //var frame= document.getAnonymousElementByAttribute(this, 'anonid', 'frame');
        var mythis = this    
         function showImage()
         {
            var e = document.createElementNS("http://www.w3.org/1999/xhtml", 'embed');
            e.setAttribute('type', "application/x-vlc-plugin");
            e.setAttribute('version', "VideoLAN.VLCPlugin.2");
            e.setAttribute('id', "vlc");
            e.setAttribute('class', "mediaplayer");
            e.setAttributeNS('http://www.mozilla.org/xbl', 'inherits', 'top,left,width,height')
            mythis.appendChild(e);

            mythis._vlc = e;
            
            e.setAttribute('top', mythis.getAttribute('top'));
            e.setAttribute('left', mythis.getAttribute('left'));
            e.setAttribute('height', mythis.getAttribute('height'));
            e.setAttribute('width', mythis.getAttribute('width'));
            
            if(mythis.getAttribute('invisible') == 'true') // hiding bound obj means player not created
                e.setAttribute('hidden', 'true');
            
            if (mythis._readyFunc)
            {
                setTimeout(mythis._readyFunc, 1);
            }
         }
         setTimeout(showImage, 100); // so layout completes without image
        ]]>
     </constructor> 

   <property name="onPlayerReady"   
            onget="return this._readyFunc;// attrib converts everthing to a string"
            onset="this._readyFunc = val; return val;"/>


   <property name="isPlaying" readonly="true"   
            onget="return this._vlc.playlist.isPlaying;" />

   <method name='play'>
    <parameter name="mrl" />
    <body><![CDATA[
        const vlc = this._vlc;
        vlc.playlist.clear();
        Components.utils.import("resource://modules/utils.js");
        if (isArray(mrl))
        {
            function addToPlaylist(amrl)
            {
               vlc.playlist.add(amrl);
            }
            mrl.forEach(addToPlaylist);
            vlc.playlist.play(); // first I hope
        }
        else
        {
            var item = vlc.playlist.add(mrl);
            vlc.playlist.playItem(item);
        }
        
        this._poller = setInterval(this._pollState, 4000);
        ]]>
    </body>
    </method>

   <method name='_pollState'>
    <body><![CDATA[
        // TODO prolly need a state machine if vids can take a while to start
        const vlc = mythis._vlc;
        if (vlc.input.state == 0) // idle
        {
            // hack but there seems no easy way, the API rather sucks here
            // if this causes glitches then we'll need to reset the playlist
            function loop()
            {
              vlc.playlist.play();
              vlc.playlist.next(); // next loops when playing
            } 
            // loop if still idle after a short time
            setTimeout(function(){if (vlc.input.state == 0) loop();}, 500); 
        }
        ]]>
    </body>
    </method>
            

   <method name='stop'>
     <body><![CDATA[
        if (this._poller)
            clearInterval(this._poller);
        this._vlc.playlist.stop();
        ]]>
    </body>
    </method>
 
   <method name='togglePause'>
     <body><![CDATA[
        // no need to close poller as it will see we are paused
        if (this._vlc.input.state == 3) // playing
            this._vlc.playlist.togglePause();
        else if (this._vlc.input.state == 4) // paused
            this._vlc.playlist.play();
        ]]>
    </body>
    </method>
 
   <method name='restart'>
    <body><![CDATA[
        this._vlc.playlist.stop();
        // poller will restart it
        ]]>
    </body>
    </method>
  
  <method name='prevItem'>
    <body><![CDATA[
        this._vlc.playlist.prev();
        // poller will restart it
        ]]>
    </body>
    </method>

  <method name='nextItem'>
    <body><![CDATA[
        this._vlc.playlist.next();
        // poller will restart it
        ]]>
    </body>
    </method>

  <method name='toggleMute'>
     <body><![CDATA[
        this._vlc.audio.mute = !this._vlc.audio.mute;
        ]]>
    </body>
    </method>
 
   <method name='incVolume'>
     <body><![CDATA[
        this.changeVolume(1);
        ]]>
    </body>
    </method>

   <method name='decVolume'>
     <body><![CDATA[
        this.changeVolume(-1);
        ]]>
    </body>
    </method>

  <method name='changeVolume'>
    <parameter name="upDown" />
    <body><![CDATA[
        const VOLSTEPS = 8;
        const VOLSTEP = Math.floor(this._MAXVOL / VOLSTEPS);
        const delta =  (upDown > 0) ? VOLSTEP : (upDown < 0) ? -VOLSTEP : 0;
        var newVol = this._vlc.audio.volume + delta
        newVol = Math.max(this._MINVOL, newVol);
        newVol = Math.min(newVol, this._MAXVOL);
        this._vlc.audio.volume = newVol;
        ]]>
    </body>
    </method>

  <method name='setVolume'>
    <parameter name="pc" />
    <body><![CDATA[
        var newVol = this._vlc.audio.volume + (this._MAXVOL * Math.floor(pc / 100) )
        newVol = Math.max(this._MINVOL, newVol);
        newVol = Math.min(newVol, this._MAXVOL);
        this._vlc.audio.volume = newVol;
        ]]>
    </body>
    </method>
    
  </implementation>

  </binding>
  
</bindings>

